## 操作符

### 左移右移

```c
// 操作符详解 左移右移

int main() 
{
	int a = -1;
	int b = a >> 1; // 右移操作符 使用的是算术右移

	// 右移操作符
	// 1.算术右移 - 二进制位右移，左边补右边的数  
	// 2.逻辑右移 - 二进制位右移，左边补0，右边省去

	// 整数在内存中存储的是补码 
    // 正整数的原码反码补码一样；负整数的反码是除了原码符号位其他位全部取反，补码是反码加一
	printf("%d\n", b);

	return 0;
}
```



### 按位异或实现变量交换

```c
int main()
{
	// 0 ^ a = a ; a ^ a = 0;
	int a = 3;
	int b = 5;
	printf("a = %d, b = %d \n", a, b);
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	printf("a = %d, b = %d \n", a, b);
	return 0;
}
```



### 计算整数二进制位中的1的个数

```c
// 计算整数二进制位中的1的个数

int count_one(int n)
{
	int count = 0;
	for (int i = 0; i < 32; i++)
	{
		if (((n >> i) & 1) == 1) // 个位&1得到个位数字
		{
			count++;
		}
	}
	return count;
}

int count_one_1(int n)
{
	int count = 0;
	while (n)
	{
		n &= (n - 1);
		count++;
	}
	return count;
}

int main()
{
	int a = 7;
	int ret_1 = count_one(a);
	int ret_2 = count_one_1(a);
	printf("%d    ", ret_1);
	printf("%d", ret_1);
}
```

```c
// sizeof 操作符

void test1(int arr[])
{
	printf("%d ", sizeof(arr));
}

void test2(char ch[])
{
	printf("%d ", sizeof(ch)); // 计算的是指针地址(4字节)
}

int main()
{
	int arr[10] = { 0 };
	char ch[10] = { 0 };
	printf("%d ", sizeof(arr));  // 40
	printf("%d ", sizeof(ch)); // 10
	test1(arr); // 4
	test2(ch); // 4

	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////

// 按位取反
int main()
{
	int a = 0;
	printf("%d ", ~a);
	// 0的补码         00000000 00000000 00000000 00000000
	// 按位取反后的补码  11111111 11111111 11111111 11111111  
	// 反码            11111111 11111111 11111111 11111110
	// 补码            10000000 00000000 00000000 00000001

}
```



### 逻辑操作符 - 易错点

```c
// 逻辑操作符 - 易错点：&&-前面为假后面不再计算，||-前面为真后面不再计算

int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	//i = a++ && ++b && d++; // 输出 1 2 3 4,因为逻辑表达式&&，前面为假整体即为假，后面根本不算了
	i = a++ || ++b || d++;   // 输出 1 3 3 4,有一个为真整体为真，所以在a++为0时，再计算一下++b，为真后不再算了
	printf("a = %d\n b = %d\n c = %d\n d = %d\n", a, b, c, d);

	return 0;
}
```



### []下标引用操作符

```c
// []下标引用操作符 - arr[4] <==> *(arr+4) <==> 4[arr]

int main()
{
	int arr[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

	printf("%d\n", *(arr + 4));
	printf("%d\n", arr[4]);
	printf("%d\n", 4[arr]); // 定义数组的时候不能这么写

	return 0;
}
```



### 结构体访问操作符

```c
// 结构体访问操作符 - 结构体变量.成员名 - 结构体指针->成员名

struct Book
{
	char name[20];
	int price;
};

int main()
{
	struct Book b = { "c语言程序设计", 35 };
	printf("书名：%s 定价：%d\n", b.name, b.price);

	struct Book* pb = &b; // struct Book是一个类型，创建一个这个类型的指针
	printf("书名：%s 定价：%d\n", pb->name, pb->price); // 通过指针访问结构体对象得用箭头

	return 0;
}
```



### 表达式求值

> **隐式类型转换
> 
> **C的整型算术运算总是至少以缺省整型类型的精度来进行的。
> 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为**整型
> 提升**。
> **整型提升的意义**：
> 表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度
> 一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
> 因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长
> 度。
> 通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令
> 中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转
> 换为int或unsigned int，然后才能送入CPU去执行运算  



```c
// 整型提升 

int main()
{
	char a = 3;   // 0000 0011
	char b = 127; // 0111 1111
	char c = a + b;
	// a和b发生整型提升
	// a        00000000 00000000 00000000 00000011 提升后 拿符号位的数字补充
	// b        00000000 00000000 00000000 01111111 提升后 
	// a+b      00000000 00000000 00000000 10000010
	// c=a+b    10000010  因为c是char类型的，只有一个字节
	// %d 打印c  11111111 11111111 11111111 10000010  按照%d打印c需要整型提升
	// c原码     10000000 00000000 00000000 01111110  按位取反再加一 -126
	printf("%d\n", c); // 所以输出-126
}
  
/////////////////////////////////////////////////////////////////////////////////////////

int main()
{
	char a = 0xb6;      // 1011 0110
	short b = 0xb600;   // 1011 0110 0000 0000
	int c = 0xb6000000; // 1011 0110 0000 0000 0000 0000 0000 0000

	if (a == 0xb6)   // 发生了整型提升 1111 1111 1111 1111 1111 1111 1011 0110
		printf("a");
	if (b == 0xb600) // 发生了整型提升 1111 1111 1111 1111 1011 0110 0000 0000
		printf("b");
	if (a == 0xffffffb6)
		printf("d");
	if (c == 0xb6000000)
		printf("c");

	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////

int main()
{

	char c = 1;
	printf("%u\n", sizeof(c));  // 1
	printf("%u\n", sizeof(+c)); // 4
	printf("%u\n", sizeof(!c)); // 1

	return 0;

}

/////////////////////////////////////////////////////////////////////////////////////////

int main()
{

	char c = 1;
	printf("%u\n", sizeof(c));  // 1
	printf("%u\n", sizeof(+c)); // 4
	printf("%u\n", sizeof(!c)); // 1

	return 0;

}
```

