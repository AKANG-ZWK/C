# C语言_进阶

## 数据在内存中的存储

- 大小端

  > **大端字节序**：把一个数的**低**位字节序的内容放在**高地址**处，把高位字节序内容放在低地址处。
  >
  > **小端字节序**：把一个数的**低**位字节序的内容放在**低地址**处，把高位字节序内容放在高地址处。

  ```c
  // 数据在内存中的存储
  
  int main()
  {
  	// 一个变量，去掉名字，剩下的是类型
  	int a;
  	// 数组其实也是一种类型，去掉数组名，剩下的是数组的类型
  	int arr[10];
  	char ch[5];
  
  	return 0;
  }
  ```

  ```c
  // 判断是大端字节序还是小端字节序
  
  int check_sys()
  {
  	int i = 1;
  
  	return (*(char*)&i);
  }
  
  int main()
  {
  	int ret = check_sys();
  	if (ret == 1)
  	{
  		printf("小端\n");
  	}
  	else
  	{
  		printf("大端\n");
  	}
  
  	return 0;
  }
  ```

  ### 整型提升、算数转换易错题

  ```c
  int main()
  {
  	char a = -1;
  	// -1 的补码 - 11111111 111111111 11111111 11111111
  	// 存到char里面 - 11111111
  	// 输出 - 整型提升 - 11111111 11111111 11111111 11111111 - 原码还是-1
  	signed char b = -1; // 绝大多数编译器里面 char 就是 signed char
  
  	unsigned char c = -1;
  	// -1 的补码 - 11111111 111111111 11111111 11111111
  	// 存到unsigned char里面 - 11111111
  	// 输出 - 整型提升 - 无符号补0 - 00000000 00000000 00000000 11111111 - 255
  
  	printf("%d %d %d\n", a, b, c);
  
  	return 0;
  }
  ```

  ```c
  // 超级易错 - 关于整型提升的定义
  
  int main()
  {
  	char a = -128; // 跟128结果一样
  	//-128 - 原码 - 10000000 00000000 00000000 1000 0000
  	//-128 - 补码 - 11111111 11111111 11111111 1000 0000
  	//存到char里面 - 1000 0000
  	//整型提升 - 11111111 11111111 11111111 10000000
  	//按照无符号类型输出：(2^32-1)-(2^7-1)
  
  	printf("%u\n", a); // 打印无符号整型
  
  	return 0;
  }
  ```

  ```c
  // 猪油蒙了心了
  
  int main()
  {
  	int i = -20;
  	unsigned int j = 10;
  	printf("%d\n", i + j);
  	//按照补码的形式进行运算，最后格式化成为有符号整数
  }
  ```

  ```c
  int main()
  {
  	unsigned int i;
  
  	for (i = 9; i >= 0; i--) 
  	{
  		printf("%u ", i);
  	}
  	// 死循环，无符号类型永远大于一，遇到负数会按照正数处理
  	// 值得注意的是，我在i=0时，对于i-1，产生的疑惑，不知道该怎么处理
  	// 实际上，i-1就是等于-1的，按照减法的逻辑去算就行，然后翻译成补码就行
  	return 0;
  }
  ```

  ```c
  int main()
  {
  	char a[1000];
  	int i;
  	for (i = 0; i < 1000; i++)
  	{
  		a[i] = -1 - i;
  	}
  	printf("%d ", strlen(a));
  	 /*
  		 char的范围是[-128，127],所以当i=128时，出现异常；
  		 -1-128=-129
  		 -129 - 原码 - 10000000 00000000 00000000 10000001
  				补码 - 11111111 11111111 11111111 01111111
  		 存到char里面 - 01111111 = 127
  		 -1-129=-130
  		 -130 - 原码 - 10000000 00000000 00000000 10000010
  				补码 - 11111111 11111111 11111111 01111110
  		 存到char里面 - 01111110 = 126
  		 可以看出从i=128之后，a[i]的结果在递减，以此类推，直到a[i]=0时，0='\0'，
  		 此时数组长度为strlen的返回值，a[i]中的值为：[-1,-128],[127,1] 共255个数字
  	 */
  	// a[i]中的值其实一直在循环，只不过统计到0之前
  	// 可以看出一个规律：char的存储范围是[-128,127],相当于表盘的一圈，超出范围的数字，
  	// 也会处于这个范围
  	return 0;
  }
  ```

  ### 关于类型的小规律

  ```c
  // 关于类型的小规律
  
  int main()
  {
  	char a = 130;
  	printf("%d\n", a); // 输出-126
  	// char的范围[-128,127],能存的数字都在这个范围，超出的左超几个，右进几个
  	// 例如 130，右超3位，左进三位就是-126
  
  	unsigned char b = 257; // 输出1
  	printf("%d\n", b);
  	// unsigned char 的范围是：[0,255]
  	// 257右超2位，左进2位就是1
  
  	return 0;
  }
  ```

  ### 特别注意事项

  1. 分清楚数据类型char 8个位，int 32个位
  2. 少于32个位才会整型提升，有符号补充符号位，无符号补充0
  3. 按照补码形式运算
  4. 注意输出格式
  5. 格子要清！！！

  ### 浮点数在内存中的存储

  > 根据国际标准IEEE（电气和电子工程协会）754，二进制浮点数V可表示为以下形式:
  >
  > (-1)^S * M * 2^E  — (-1)^S 表示符号位    M 表示有效数字   2^E表示指数位 
  >
  > 存的时候把S M E存下就行了

  ```c
  int main()
  {
  	float f = 5.5f;
  	// 101.1
  	// 1.011 * 2^2
  	// (-1)^0 * 1.011 * 2^2   S = 0   M = 011  E = 2+127 = 129 = 10000001
  	// 内存中 - 0 10000001 011 000000000 000000000 0000
  
  	return 0;
  }
  ```

  ![image-20220330152328216](C:\Users\AKANG\AppData\Roaming\Typora\typora-user-images\image-20220330152328216.png)

  ![image-20220330152400241](C:\Users\AKANG\AppData\Roaming\Typora\typora-user-images\image-20220330152400241.png)

  ```c
  int main()
  {
  	int n = 9;
  	// 0 0000000 0 0000000 00000000 00001001
  	float* pFloat = (float*)&n;
  	// 用float* 类型去访问它 S=0  E=0000000 0  M=0000000 00000000 00001001
  	// (-1)^0 * 2 ^ -126 * 0.0000000 00000000 00001001 ==> 趋近0的一个数
  	printf("%d\n", n); // 输出9
  	printf("%f\n", *pFloat); // 以float类型的指针去访问n，输出0.0000000
  
  	*pFloat = 9.0;
  	// 9.0存到*pFloat中
  	// 9.0 <==> 1001.0
  	//     <==> 1.001 * 2^3
  	//     <==> (-1)^0 * 1.001 * 2^3
  	// S = 0   E = 3 + 127 = 130 = 1000 0010  M = 001
  	// 内存中 ： 0 10000010 001 00000000000000000000
  
  	printf("%d\n", n);                 
  	// 以%d的视角输出：原码 - 0 10000010 001 00000000000000000000
  
  	printf("%f\n", *pFloat);
  	// 以%f的视角输出就是正常的 9.0
  	return 0;
  }
  ```

  **注意：当我们程序输出奇奇怪怪的数据时，该考虑是不是类型没匹配对**
