#### 计算结构体占用内存大小

> 首先得掌握结构体的对齐规则：
>
> **对齐数** = 编译器默认的一个对齐数 与 该成员大小的**较小值**。（VS中默认的值为8）
>
> 1. 第一个成员在与结构体变量偏移量为0的地址处。
> 2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
> 3. 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
> 4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整
>    体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。  

**为什么存在内存对齐**?

大部分的参考资料都是如是说的：

1. 平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能
   在某些地址处取某些特定类型的数据，否则抛出硬件异常。

2. 性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的
   内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

   **总体来说：**
   结构体的内存对齐是拿空间来换取时间的做法。  让占用空间小的成员尽量在一起。

```c
// 计算结构体占用内存大小

struct S
{
	char c1;
	int i;
	char c2;

};

int main()
{
	printf("%d\n", sizeof(struct S)); // 输出12
	// 为什么会输出12呢？这与结构体的对齐规则有关
	// 结构体第一个成员从起始位存放
	// 从第二个成员开始，要放在对应的对齐数的位置
	// 对齐数规则： 自身大小与默认对齐数（vs默认为8）的较小值
	// 结构体总的大小，成员对齐数最大值的整数倍           

	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////

// 有嵌套结构体的情况
// 计算结构体占用内存大小

struct S
{
	double b1; // 对齐数  8  从0开始 0-7
	int i;     // 对齐数  4         8-11
	char c2;   // 对齐数  1         12 
	// 最大对齐数 8 内存总大小8的倍数 即16
};

struct Q
{
	char a1; // 对齐数 1 从0开始 0
	struct S a2; // 内部最大对齐数 8 1-16
	double a3; // 对齐数 8 24-32
	// 最大对齐数8 总内存为8的倍数
};

int main()
{
	printf("%d\n", sizeof(struct Q)); // 输出32

	return 0;
}
```

```c
struct S
{
	char c;
	int i;
};

int main()
{
	struct S s = { 0 };
	printf("%d\n", sizeof(s));

	printf("%d\n", offsetof(struct S, c)); // 这块输出的是成员在内存中与结构体初始地址的偏移量
	printf("%d\n", offsetof(struct S, i)); // 

	return 0;
}
```

#### 修改默认对齐数

```c
// 修改默认对齐数
// 默认对齐数为8时
struct S1
{
	char c1; // 0
	// 1-7
	double d; // 8 15
	char c2; // 16
	// 0-16 一共17个字节，不是8的倍数，所以需要浪费17-23，凑够24个字节
};

#pragma pack(4)

struct S2
{
	char c1; // 0
	double d; // 8 4 选则较小值 4  4-11
	char c2; // 12
	// 0-12 一共13个字节，不是4的倍数，所以需要浪费13-15，凑够16个字节
};

#pragma pack(1)

struct S3
{
	char c1; // 0
	double d; // 8 1 选择 1  1-8
	char c2; // 1   9
	// 0-9 一共10个字节 前面最大对齐数是1，所以内存总大小就是1的倍数就行
};

int main()
{
	printf("%d\n", sizeof(struct S1));
	printf("%d\n", sizeof(struct S2));
	printf("%d\n", sizeof(struct S3));

	return 0;
}
```

#### 结构体传参

```c
// 结构体传参

struct S
{
	char str[20];
	int n;
};

void print1(struct S ss) // 这块的参数相当于对象的一份临时拷贝
{
	printf("%s %d\n", ss.str, ss.n);
}

void print2(const struct S* ps) // 这块还是访问的是对象的地址，用这种方法省内存
{
	printf("%s %d\n", ps->str, ps->n);
}

int main()
{
	struct S s = { "hello word", 100 };
	print1(s);
	printf("\n");
	print2(&s);

	return 0;
}
```

#### 
