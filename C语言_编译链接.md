## 编译链接

### 预处理

#### 预定义符号

```c
__FILE__ //进行编译的源文件
__LINE__ //文件当前的行号
__DATE__ //文件被编译的日期
__TIME__ //文件被编译的时间
__STDC__ //如果编译器遵循ANSI C，其值为1，否则未定义
```

```c
// 预定义符号

int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };

	for (int i = 0; i < 10; i++)
	{
		printf("file: %s |line: %d |date: %s |time: %s |arr[i]: %d\n", __FILE__,
			__LINE__,__DATE__, __TIME__, arr[i]); 
		// __FILE__当前执行文件名，__LINE__当前执行的代码行号，__DATE__日期, __TIME__时间
	}

	return 0;
}
```

#### #define

##### #define定义标识符

```c
#define c computer
#define a printf("测试")

int main()
{
	int computer = 2;
	printf("%d \n", c); // 输出为2， 程序中的c都用computer来代替

	a; // 程序中用printf("测试")替代a

	return 0;
}
```

##### #define定义宏

```c
#define MAX(X,Y) (X>Y?X:Y)

#define SQUARE(X) X*X // SQUARE(4+1) <==> 4+1*4+1 = 9 
					  // 规避上面问题的方法就是给X加上括号
#define DOUBLE(X) ((X)+(X)) // 若没有外层括号，就会导致 10*DOUBLE(x) == 10*(X)+(X)

int main()
{
	int a = 10;
	int b = 20;
	int max = MAX(a, b);
	printf("%d\n", max);
	printf("%d\n", SQUARE(5));

	return 0;
}
```

**注意：**所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中的操作或邻近操作符之间不可预料的相互作用  

1. 宏参数和#define 定义中可以出现其他#define定义的变量。但是对于宏，不能出现递归。
2. 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。  

##### #

```c
// #把字符插入的字符串中
#define PRINT(X) printf("The value of "#X" is %d\n", X)

#define PRINTF(FORMAT,X) printf("The value of "#X" is "FORMAT"\n", X)

int main()
{
	int a = 100;
	int b = 200;
	float f = 5.55;
	PRINT(a);
	PRINT(b);
	PRINTF("%f\n", f);

	return 0;
}
```

##### ##

```c
// ## - 合并两个符号为一个符号

#define CAT(X,Y) X##Y

int main()
{
	int xiaoming = 1000;
	printf("%d", CAT(xiao, ming));

	return 0;
}
```

##### 带副作用的宏参数

当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。 例如：
`x+1;//不带副作用`
`x++;//带有副作用`

**注意：**带有副作用的参数在任何地方都要谨慎使用

##### 宏和函数对比

**那为什么不用函数来完成这个任务？ 原因有二：**

1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以宏比函数在程序
   的规模和速度方面更胜一筹。
2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏则可以适用于整形、长整型、浮点型等可以用于>来比较的类型。宏是类型无关的。

**当然和宏相比函数也有劣势的地方：**

1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。
2. 宏是没法调试的。
3. 宏由于类型无关，也就不够严谨。
4. 宏可能会带来运算符优先级的问题，导致程容易出现错。
   宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。  

```c
// 宏和函数的对比
// 比较简单的代码使用宏会效率高很多，因为宏在程序预处理阶段会直接变成一行代码，省去了调用函数的过程
// 小型的计算使用宏好一点，而且宏不在乎参数类型

#define MAX(X,Y) ((X)>(Y)?(X):(Y))

int Max(int a, int b)
{
	return a > b ? a : b;
}

int main()
{
	int a = 10;
	int b = 20;
	float c = 1.2;
	float d = 12.3;
	printf("%d\n", MAX(a, b));

	printf("%d\n", Max(a, b));

	printf("%f\n", MAX(c, d));

	return 0;
}
```

```c
// 可以通过宏的方式为传递参数类型

#define MALLOC(num,type) (type*)malloc(num * sizeof(type))

int main()
{
	int* p = MALLOC(10, int);

	return 0;
}
```

| 属 性                   | #define定义宏                                                | 函数                                                         |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 代 码 长 度             | 每次使用时，宏代码都会被插入到程序中。除了非常小的宏 之外，程序的长度会大幅度增长 | 函数代码只出现于一个地方；每次使 用这个函数时，都调用那个地方的同 一份代码 |
| 执 行 速 度             | 更快                                                         | 存在函数的调用和返回的额外开销， 所以相对慢一些              |
| 操 作 符 优 先 级       | 宏参数的求值是在所有周围表达式的上下文环境里，除非加 上括号，否则邻近操作符的优先级可能会产生不可预料的后 果，所以建议宏在书写的时候多些括号。 | 函数参数只在函数调用的时候求值一 次，它的结果值传递给函数。表达式 的求值结果更容易预测。 |
| 带 有 副 作 用 的 参 数 | 参数可能被替换到宏体中的多个位置，所以带有副作用的参 数求值可能会产生不可预料的结果。 | 函数参数只在传参的时候求值一次， 结果更容易控制。            |
| 参 数 类 型             | 宏的参数与类型无关，只要对参数的操作是合法的，它就可 以使用于任何参数类型。 | 函数的参数是与类型有关的，如果参 数的类型不同，就需要不同的函数， 即使他们执行的任务是不同的。 |
| 调 试                   | 宏是不方便调试的                                             | 函数是可以逐语句调试的                                       |
| 递 归                   | 宏是不能递归的                                               | 函数是可以递归的                                             |

##### 取消宏

```c
#define MAX 100
int main()
{
	printf("%d ", MAX);
#undef MAX // 取消宏
//	printf("%d ", MAX);

	return 0;
}
```
