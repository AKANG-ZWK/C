### 笔试题

```c
// 比较复杂的题，需要谨慎

int main()
{
	int a[5][5];
	int(*p)[4];
	p = a;
	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);

	// a这个数组表示成右边的样子 00000 00000 00000 00000 00000 
	// p指向一个四个元素的数组，所以+1跳过4个元素 
	// p = a 让p指向a数组
	// p[4]=*(p+4) <==> 0000 0000 0000 0000    (0000)    0000 0  找到括号里的元素
	// p[4][2] <==> (00 00 ) 
	// a[4][2] <==> 00000 00000 00000 00000 (00 000) 
	// 俩地址之间差了4个单位
	// &p[4][2]-&a[4][2] == -4
	// 原码 - 10000000 00000000 00000000 00000100
	// 补码 - 11111111 11111111 11111111 11111110 内存中存的样子
	// %d输出时翻译成原码输出 %p直接当作十六进制数输出 4个1表示一个f 

	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////

// 蛮坑的一道题，但是只要记得逗号表达式就不会错

int main()
{
	int a[3][2] = { (0, 1), (2, 3), (4, 5) }; // 等价于{1,3,5}
	int* p;
	p = a[0];
	printf("%d", p[0]);
	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////

// 有时间就要多琢磨的题
 
int main()
{
	int a[4] = { 1, 2, 3, 4 };
	int* ptr1 = (int*)(&a + 1); // 数组跳过一个单位，指向4后面
	int* ptr2 = (int*)((int)a + 1);
	printf("%x,%x", ptr1[-1], *ptr2); // 妙啊，妙死了,这个题里面好几个细节，得细细道来
	/*分析
	a是数组首元素地址
	(int)a 强制类型转换为整型数字，再+1后值增加了1，这里的值增加1，就是增加1个字节
	因为数据在内存上是以十六进制来存储的，所以+1相当于，在十六进制位上增加了1个单位，就是1个字节
	(int*) 再对其强制类型转换为整型指针类型，整型指针类型4个字节，存在内存上，每2个位表示1个字节
	所增加1个字节后，指针在十六进制位上移动2个位，再把这个数按照十六进制数打印出来
	然后因为数据在内存上是大端存储法，所以翻译成数字时会反过来，00 00 00 02 反过来就是 20 00 00 00
	01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00
	移动两位 00 00 00 02 

	*/
	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////

// 指针笔试题 - 2

struct Test
{
	int Num;
	char* pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}*p;
// 假设p 的值为0x100000。 如下表表达式的值分别为多少？
// 已知结构体test类型的变量大小是20个字节
int main()
{
	// 0x1 十六进制数
	printf("%p\n", p + 0x1); // 这块p是个指针，所以+1相当于加一个单位20字节
	printf("%p\n", (unsigned long)p + 0x1); // p 强制类型转换为整型，所以就是单纯的+1
	printf("%p\n", (unsigned int*)p + 0x1); // p 强制类型转换为int*，所以+1个单位相当与加4个字节
	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////

// 指针笔试题 - 1

int main()
{
	int a[5] = { 1, 2, 3, 4, 5 };
	int* ptr = (int*)(&a + 1);
	printf("%d,%d", *(a + 1), *(ptr - 1)); // 2，5

	return 0;
}
```

### 特别难的一道题

```c
// 比较难的一道题，需要注意如何画出来分析

int main()
{
	char* c[] = { "ENTER","NEW","POINT","FIRST" };
	char** cp[] = { c + 3,c + 2,c + 1,c };
	char*** cpp = cp;
	printf("%s\n", **++cpp); // POINT
	printf("%s\n", *-- * ++cpp + 3); // ER
	printf("%s\n", *cpp[-2] + 3); // ST
	printf("%s\n", cpp[-1][-1] + 1); // EW

	return 0;
}
```
